---
description:
globs: apps/app/*
alwaysApply: false
---
# Dashboard App Implementation Rules

## Core Technologies

- **Framework**: Next.js 15 App Router
- **UI**: React 19, Tailwind CSS, Shadcn UI
- **Database**: Supabase (Auth, Database, Storage)
- **State Management**: nuqs (URL state), Zustand (client state)
- **Forms**: next-safe-action, react-hook-form, zod
- **Background Jobs**: Trigger.dev v3
- **Internationalization**: next-intl

## Project Structure

```
apps/app/
├── src/
│   ├── app/
│   │   ├── [locale]/
│   │   │   ├── (dashboard)/    # Authenticated routes
│   │   │   ├── (private)/      # Auth pages (login, signup)
│   │   │   └── layout.tsx      # Root layout with locale
│   │   └── api/                # API routes
│   ├── actions/                # Server actions
│   ├── components/             # React components
│   ├── hooks/                  # Custom hooks
│   ├── store/                  # Zustand stores
│   ├── utils/                  # Utilities
│   └── locales/               # i18n translations
└── jobs/                      # Trigger.dev tasks
```

## Authentication Implementation

### Middleware Setup

```typescript
// middleware.ts
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'
import createMiddleware from 'next-intl/middleware'

const intlMiddleware = createMiddleware({
  locales: ['en'],
  defaultLocale: 'en'
})

export async function middleware(request: NextRequest) {
  // Handle internationalization first
  const response = intlMiddleware(request)
  let supabaseResponse = NextResponse.next({
    request,
    headers: response.headers,
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({
            request,
            headers: response.headers,
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  const { data: { user } } = await supabase.auth.getUser()

  // Protect dashboard routes
  if (request.nextUrl.pathname.includes('/(dashboard)') && !user) {
    const url = request.nextUrl.clone()
    url.pathname = '/login'
    return NextResponse.redirect(url)
  }

  return supabaseResponse
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)'],
}
```

### Server Component Auth Check

```typescript
// app/[locale]/(dashboard)/layout.tsx
import { createClient } from "@proxed/supabase/server";
import { redirect } from "next/navigation";

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  return <>{children}</>;
}
```

## Server Actions Pattern

### Action Client Setup

```typescript
// actions/safe-action.ts
import { createSafeActionClient } from "next-safe-action";
import { createClient } from "@proxed/supabase/server";
import { getUser } from "@proxed/supabase/cached-queries";

export const actionClient = createSafeActionClient({
  handleServerError: (e) => {
    console.error("Action error:", e);
    return e instanceof Error ? e.message : "An error occurred";
  },
});

export const authActionClient = actionClient
  .use(async ({ next }) => {
    const userData = await getUser();
    const user = userData?.data;
    const supabase = await createClient();

    if (!user) {
      throw new Error("Unauthorized");
    }

    return next({
      ctx: {
        supabase,
        user,
      },
    });
  });
```

### Action Implementation

```typescript
// actions/project-actions.ts
"use server";

import { z } from "zod";
import { revalidatePath } from "next/cache";
import { authActionClient } from "./safe-action";

const createProjectSchema = z.object({
  name: z.string().min(1).max(50),
  description: z.string().optional(),
  teamId: z.string().uuid(),
});

export const createProject = authActionClient
  .schema(createProjectSchema)
  .action(
    async ({
      parsedInput: { name, description, teamId },
      ctx: { user, supabase }
    }) => {
      // Verify team membership
      const { data: member } = await supabase
        .from("team_members")
        .select("role")
        .eq("team_id", teamId)
        .eq("user_id", user.id)
        .single();

      if (!member) {
        throw new Error("Not a member of this team");
      }

      // Create project
      const { data: project, error } = await supabase
        .from("projects")
        .insert({
          name,
          description,
          team_id: teamId,
          created_by: user.id,
        })
        .select()
        .single();

      if (error) {
        throw new Error(error.message);
      }

      revalidatePath(`/teams/${teamId}/projects`);

      return { project };
    }
  );
```

## URL State Management with nuqs

### Search Params Cache

```typescript
// utils/search-params.ts
import {
  createSearchParamsCache,
  parseAsInteger,
  parseAsString,
  parseAsStringEnum,
} from "nuqs/server";

export const projectsSearchParams = createSearchParamsCache({
  page: parseAsInteger.withDefault(1),
  perPage: parseAsInteger.withDefault(20),
  search: parseAsString,
  status: parseAsStringEnum(["active", "archived"]).withDefault("active"),
  sortBy: parseAsStringEnum(["name", "created_at"]).withDefault("created_at"),
  sortOrder: parseAsStringEnum(["asc", "desc"]).withDefault("desc"),
});
```

### Client Component Usage

```typescript
// components/projects/project-filters.tsx
'use client'

import { useQueryState } from 'nuqs'

export function ProjectFilters() {
  const [search, setSearch] = useQueryState('search', {
    shallow: false, // Triggers navigation
  })

  const [status, setStatus] = useQueryState('status', {
    defaultValue: 'active',
  })

  return (
    <div className="flex gap-4">
      <Input
        placeholder="Search projects..."
        value={search || ''}
        onChange={(e) => setSearch(e.target.value || null)}
      />
      <Select value={status} onValueChange={setStatus}>
        <SelectTrigger>
          <SelectValue />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="active">Active</SelectItem>
          <SelectItem value="archived">Archived</SelectItem>
        </SelectContent>
      </Select>
    </div>
  )
}
```

### Server Component Usage

```typescript
// app/[locale]/(dashboard)/projects/page.tsx
import { projectsSearchParams } from "@/utils/search-params";

export default async function ProjectsPage({
  searchParams,
}: {
  searchParams: unknown;
}) {
  const { page, perPage, search, status, sortBy, sortOrder } =
    projectsSearchParams.parse(searchParams);

  const projects = await getProjects({
    page,
    perPage,
    search,
    status,
    sortBy,
    sortOrder,
  });

  return (
    <div>
      <ProjectFilters />
      <ProjectsList projects={projects} />
    </div>
  );
}
```

## Zustand Store Pattern

```typescript
// store/user/store.ts
import { create } from "zustand";
import { devtools, persist } from "zustand/middleware";

interface UserStore {
  user: User | null;
  setUser: (user: User | null) => void;
  preferences: UserPreferences;
  updatePreferences: (preferences: Partial<UserPreferences>) => void;
}

export const useUserStore = create<UserStore>()(
  devtools(
    persist(
      (set) => ({
        user: null,
        setUser: (user) => set({ user }),
        preferences: {
          theme: "light",
          notifications: true,
        },
        updatePreferences: (preferences) =>
          set((state) => ({
            preferences: { ...state.preferences, ...preferences },
          })),
      }),
      {
        name: "user-storage",
        partialize: (state) => ({ preferences: state.preferences }),
      }
    )
  )
);
```

## Component Patterns

### Data Fetching Component

```typescript
// components/projects/projects-list.tsx
import { Suspense } from "react";
import { getProjects } from "@proxed/supabase/cached-queries";

async function ProjectsContent() {
  const { data: projects, error } = await getProjects();

  if (error) {
    return <ErrorState message={error.message} />;
  }

  if (!projects?.length) {
    return <EmptyState />;
  }

  return (
    <div className="grid gap-4">
      {projects.map((project) => (
        <ProjectCard key={project.id} project={project} />
      ))}
    </div>
  );
}

export function ProjectsList() {
  return (
    <Suspense fallback={<ProjectsSkeleton />}>
      <ProjectsContent />
    </Suspense>
  );
}
```

### Form Component with Server Action

```typescript
// components/projects/create-project-form.tsx
'use client'

import { useAction } from "next-safe-action/hooks";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { createProject } from "@/actions/project-actions";
import { toast } from "sonner";

export function CreateProjectForm({ teamId }: { teamId: string }) {
  const { execute, isExecuting } = useAction(createProject, {
    onSuccess: ({ data }) => {
      toast.success("Project created successfully");
      router.push(`/projects/${data.project.id}`);
    },
    onError: ({ error }) => {
      toast.error(error.serverError || "Failed to create project");
    },
  });

  const form = useForm<CreateProjectInput>({
    resolver: zodResolver(createProjectSchema),
    defaultValues: {
      teamId,
    },
  });

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(execute)} className="space-y-4">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Project Name</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <Button type="submit" disabled={isExecuting}>
          {isExecuting ? "Creating..." : "Create Project"}
        </Button>
      </form>
    </Form>
  );
}
```

## Trigger.dev Background Jobs

```typescript
// jobs/notifications.ts
import { task } from "@trigger.dev/sdk/v3";
import { createAdminClient } from "@proxed/supabase/server";
import { sendEmail } from "@proxed/mail";

export const sendProjectNotification = task({
  id: "send-project-notification",
  run: async (payload: { projectId: string; type: string }) => {
    const supabase = createAdminClient();

    // Get project and team members
    const { data: project } = await supabase
      .from("projects")
      .select("*, team:teams!inner(*, members:team_members!inner(user:users!inner(*)))")
      .eq("id", payload.projectId)
      .single();

    if (!project) {
      throw new Error("Project not found");
    }

    // Send emails to team members
    const emails = project.team.members.map((member) => ({
      to: member.user.email,
      subject: `Project Update: ${project.name}`,
      template: "project-notification",
      data: {
        projectName: project.name,
        type: payload.type,
      },
    }));

    await Promise.all(emails.map(sendEmail));
  },
});
```

## Internationalization

```typescript
// locales/en.ts
export default {
  common: {
    save: "Save",
    cancel: "Cancel",
    delete: "Delete",
    loading: "Loading...",
  },
  projects: {
    title: "Projects",
    create: "Create Project",
    empty: "No projects found",
    fields: {
      name: "Project Name",
      description: "Description",
    },
  },
} as const;

// Usage in components
import { useTranslations } from 'next-intl';

export function ProjectsPage() {
  const t = useTranslations('projects');

  return (
    <div>
      <h1>{t('title')}</h1>
      <Button>{t('create')}</Button>
    </div>
  );
}
```

## Common Patterns

### Error Boundaries

```typescript
// components/error-boundary.tsx
'use client'

export default function ErrorBoundary({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <h2 className="text-lg font-semibold">Something went wrong!</h2>
      <p className="text-muted-foreground">{error.message}</p>
      <Button onClick={reset} className="mt-4">
        Try again
      </Button>
    </div>
  )
}
```

### Loading States

```typescript
// components/loading-skeleton.tsx
export function ProjectsSkeleton() {
  return (
    <div className="space-y-4">
      {Array.from({ length: 5 }).map((_, i) => (
        <div key={i} className="rounded-lg border p-4">
          <Skeleton className="h-6 w-1/3 mb-2" />
          <Skeleton className="h-4 w-2/3" />
        </div>
      ))}
    </div>
  );
}
```

## Performance Optimizations

1. **Use React Server Components by default**
2. **Implement proper Suspense boundaries**
3. **Cache Supabase queries with Next.js cache**
4. **Use dynamic imports for heavy client components**
5. **Optimize images with next/image**
6. **Implement proper error boundaries**

## Security Best Practices

1. **Always validate user permissions in server actions**
2. **Use Row Level Security (RLS) in Supabase**
3. **Sanitize user inputs with zod schemas**
4. **Implement CSRF protection (built into server actions)**
5. **Use environment variables for sensitive data**

## Common Pitfalls

❌ Don't use 'use client' unnecessarily
❌ Don't fetch data in client components
❌ Don't store sensitive data in Zustand
❌ Don't skip RLS policies
❌ Don't forget to revalidate cache after mutations
