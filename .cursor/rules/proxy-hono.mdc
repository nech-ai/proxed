---
description:
globs: apps/proxy/*
alwaysApply: false
---
# Hono Proxy API Implementation Rules

## ğŸš¨ CRITICAL: Use Hono Framework, NOT Next.js

This proxy application uses **Hono** framework with **Bun** runtime. Do NOT generate Next.js code.

## Core Dependencies

```json
{
  "@hono/node-server": "^1.x",
  "@hono/zod-openapi": "^0.x",
  "hono": "^4.x",
  "@proxed/supabase": "workspace:*",
  "@proxed/utils": "workspace:*",
  "drizzle-orm": "^0.x",
  "postgres": "^3.x"
}
```

## Project Structure

```
apps/proxy/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.ts              # Main Hono app entry
â”‚   â”œâ”€â”€ rest/
â”‚   â”‚   â”œâ”€â”€ middleware/       # All middleware
â”‚   â”‚   â”œâ”€â”€ routes/          # Route handlers
â”‚   â”‚   â”œâ”€â”€ routers.ts       # Route registration
â”‚   â”‚   â””â”€â”€ types.ts         # Shared types
â”‚   â”œâ”€â”€ utils/               # Utilities
â”‚   â”‚   â”œâ”€â”€ circuit-breaker.ts
â”‚   â”‚   â”œâ”€â”€ stream-handler.ts
â”‚   â”‚   â”œâ”€â”€ health-checks.ts
â”‚   â”‚   â””â”€â”€ base-proxy.ts
â”‚   â””â”€â”€ db/
â”‚       â”œâ”€â”€ index.ts         # Database client
â”‚       â”œâ”€â”€ schema.ts        # Drizzle schema
â”‚       â””â”€â”€ queries/         # Database queries
â””â”€â”€ drizzle.config.ts       # Drizzle configuration
```

## Core Implementation Patterns

### 1. Main Application Setup

```typescript
import { Hono } from "hono";
import { logger } from "hono/logger";
import { cors } from "hono/cors";
import { timing } from "hono/timing";
import { etag } from "hono/etag";
import { requestId } from "hono/request-id";

const app = new Hono();

// Middleware order matters!
app.use("*", requestId());
app.use("*", logger());
app.use("*", timing());
app.use("*", cors());
app.use("*", etag());

// Apply routers
app.route("/v1", v1Router);

export default {
  port: process.env.PORT || 3002,
  fetch: app.fetch,
};
```

### 2. Route Handler Pattern

```typescript
import { Hono } from "hono";
import { z } from "zod";
import { zValidator } from "@hono/zod-validator";

const router = new Hono<{ Variables: ContextVariables }>();

// Schema definition
const requestSchema = z.object({
  model: z.string(),
  messages: z.array(z.object({
    role: z.enum(["user", "assistant", "system"]),
    content: z.string(),
  })),
  stream: z.boolean().optional(),
});

// Route implementation
router.post(
  "/chat/completions",
  zValidator("json", requestSchema),
  rateLimitMiddleware({ tier: "standard" }),
  authMiddleware,
  async (c) => {
    const body = c.req.valid("json");
    const { projectId, teamId } = c.get("auth");

    try {
      // Implementation
      return c.json({ success: true });
    } catch (error) {
      throw createError(ErrorCode.INTERNAL_ERROR, "Failed to process");
    }
  }
);
```

### 3. Middleware Pattern

```typescript
import type { MiddlewareHandler } from "hono";

export const authMiddleware: MiddlewareHandler<{
  Variables: ContextVariables;
}> = async (c, next) => {
  const apiKey = c.req.header("Authorization")?.replace("Bearer ", "");

  if (!apiKey) {
    return c.json(
      createError(ErrorCode.UNAUTHORIZED).toResponse(),
      401
    );
  }

  try {
    // Validate and set context
    const auth = await validateApiKey(apiKey);
    c.set("auth", auth);
    await next();
  } catch (error) {
    return c.json(
      createError(ErrorCode.UNAUTHORIZED).toResponse(),
      401
    );
  }
};
```

### 4. Stream Handling

```typescript
import { streamSSE } from "hono/streaming";

// For SSE streams
router.post("/stream", async (c) => {
  return streamSSE(c, async (stream) => {
    try {
      for await (const chunk of dataStream) {
        await stream.writeSSE({
          data: JSON.stringify(chunk),
          event: "message",
        });
      }
    } catch (error) {
      await stream.writeSSE({
        data: JSON.stringify({ error: error.message }),
        event: "error",
      });
    }
  });
});

// For raw streams
router.post("/raw-stream", async (c) => {
  const stream = new ReadableStream({
    async start(controller) {
      try {
        for await (const chunk of dataStream) {
          controller.enqueue(chunk);
        }
        controller.close();
      } catch (error) {
        controller.error(error);
      }
    },
  });

  return new Response(stream, {
    headers: {
      "Content-Type": "application/octet-stream",
      "Transfer-Encoding": "chunked",
    },
  });
});
```

### 5. Database Queries with Drizzle

```typescript
import { db } from "@/db";
import { apiKeys, projects, teams } from "@/db/schema";
import { eq, and } from "drizzle-orm";

// Query patterns
export async function getProjectById(projectId: string) {
  const [project] = await db
    .select()
    .from(projects)
    .where(eq(projects.id, projectId))
    .limit(1);

  return project;
}

// With joins
export async function getProjectWithTeam(projectId: string) {
  const [result] = await db
    .select({
      project: projects,
      team: teams,
    })
    .from(projects)
    .innerJoin(teams, eq(projects.teamId, teams.id))
    .where(eq(projects.id, projectId))
    .limit(1);

  return result;
}
```

### 6. Circuit Breaker Implementation

```typescript
import { CircuitBreaker } from "@/utils/circuit-breaker";

const anthropicBreaker = new CircuitBreaker({
  failureThreshold: 5,
  recoveryTimeout: 60000,
  monitoringPeriod: 120000,
});

// Usage in route
router.post("/anthropic/*", async (c) => {
  return anthropicBreaker.execute(async () => {
    // Proxy to Anthropic
    return await proxyToAnthropic(c);
  });
});
```

### 7. Error Handling

```typescript
import { HTTPException } from "hono/http-exception";

// Global error handler
app.onError((err, c) => {
  if (err instanceof HTTPException) {
    return err.getResponse();
  }

  if (err instanceof AppError) {
    return c.json(err.toResponse(), err.status);
  }

  console.error("Unhandled error:", err);
  return c.json(
    createError(ErrorCode.INTERNAL_ERROR).toResponse(),
    500
  );
});
```

### 8. Health Checks

```typescript
router.get("/health", async (c) => {
  const health = await performHealthChecks({
    checkDatabase: true,
    checkRedis: true,
    checkExternalAPIs: true,
  });

  const status = health.status === "healthy" ? 200 : 503;
  return c.json(health, status);
});
```

### 9. Rate Limiting

```typescript
export const rateLimitMiddleware = (options: RateLimitOptions) => {
  return async (c: Context, next: Next) => {
    const identifier = c.get("auth")?.teamId || c.req.header("CF-Connecting-IP");

    const { allowed, remaining, reset } = await checkRateLimit(
      identifier,
      options.tier
    );

    c.header("X-RateLimit-Limit", String(options.limit));
    c.header("X-RateLimit-Remaining", String(remaining));
    c.header("X-RateLimit-Reset", String(reset));

    if (!allowed) {
      return c.json(
        createError(ErrorCode.TOO_MANY_REQUESTS).toResponse(),
        429
      );
    }

    await next();
  };
};
```

### 10. Type Safety

```typescript
// Define context variables
export interface ContextVariables {
  auth: {
    projectId: string;
    teamId: string;
    apiKeyId: string;
  };
  requestId: string;
  startTime: number;
}

// Use in Hono instance
const app = new Hono<{ Variables: ContextVariables }>();
```

## Testing Patterns

```typescript
import { describe, it, expect, beforeEach, mock } from "bun:test";
import app from "@/index";

describe("API Routes", () => {
  it("should handle chat completions", async () => {
    const response = await app.fetch(
      new Request("http://localhost/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer test-key",
        },
        body: JSON.stringify({
          model: "gpt-4",
          messages: [{ role: "user", content: "Hello" }],
        }),
      })
    );

    expect(response.status).toBe(200);
    const data = await response.json();
    expect(data).toHaveProperty("choices");
  });
});
```

## Performance Best Practices

1. **Use streaming for large responses**
2. **Implement connection pooling for database**
3. **Add caching where appropriate**
4. **Use ETags for HTTP caching**
5. **Implement circuit breakers for external services**

## Security Requirements

1. **Always validate API keys**
2. **Implement rate limiting**
3. **Validate request bodies with Zod**
4. **Add security headers**
5. **Log security events**

## Bun-specific Considerations

1. **Compression**: Handle via reverse proxy (Cloudflare/Nginx)
2. **Use Bun's built-in test runner**
3. **Leverage Bun's speed for TypeScript**
4. **Use native Bun APIs where beneficial**

## Common Pitfalls to Avoid

âŒ Don't use Next.js patterns
âŒ Don't create new database connections per request
âŒ Don't forget to handle streaming responses
âŒ Don't skip request validation
âŒ Don't ignore circuit breaker states
