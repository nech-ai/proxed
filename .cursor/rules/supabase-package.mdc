---
description:
globs: apps/app/*,packages/supabase/*
alwaysApply: false
---
# Supabase Package Implementation Rules

## Overview

The Supabase package provides shared Supabase client configurations, queries, mutations, and TypeScript types for database operations across all applications.

## Core Technologies

- **Client**: Supabase JS SDK
- **Types**: Generated from database schema
- **Caching**: Next.js unstable_cache
- **Auth**: Supabase Auth integration

## Project Structure

```
packages/supabase/
├── src/
│   ├── clients/          # Supabase client configurations
│   │   ├── api.ts       # Service role client
│   │   ├── client.ts    # Browser client
│   │   ├── job.ts       # Background job client
│   │   ├── server.ts    # Server client
│   │   └── ssr.ts       # SSR-safe client
│   ├── queries/         # Database queries
│   │   ├── cached-queries.ts
│   │   └── index.ts
│   ├── mutations/       # Database mutations
│   │   └── index.ts
│   ├── types/          # TypeScript types
│   │   ├── db.generated.ts
│   │   ├── db.ts
│   │   └── billing.ts
│   └── utils/          # Utilities
│       └── storage.ts
```

## Client Implementations

### Browser Client

```typescript
// clients/client.ts
import { createBrowserClient } from '@supabase/ssr'
import type { Database } from '../types/db.generated'

export function createClient() {
  return createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```

### Server Client

```typescript
// clients/server.ts
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'
import type { Database } from '../types/db.generated'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // Ignore - called from Server Component
          }
        },
      },
    }
  )
}
```

### Service Role Client

```typescript
// clients/api.ts
import { createClient as createSupabaseClient } from '@supabase/supabase-js'
import type { Database } from '../types/db.generated'

export function createAdminClient() {
  return createSupabaseClient<Database>(
    process.env.SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      auth: {
        autoRefreshToken: false,
        persistSession: false,
      },
    }
  )
}
```

### Background Job Client

```typescript
// clients/job.ts
import { createClient as createSupabaseClient } from '@supabase/supabase-js'
import type { Database } from '../types/db.generated'

let client: ReturnType<typeof createSupabaseClient<Database>> | null = null

export function createJobClient() {
  if (!client) {
    client = createSupabaseClient<Database>(
      process.env.SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!,
      {
        auth: {
          autoRefreshToken: false,
          persistSession: false,
        },
      }
    )
  }
  return client
}
```

## Query Patterns

### Basic Queries

```typescript
// queries/index.ts
import { createClient } from '../clients/server'
import type { Database } from '../types/db.generated'

type Tables = Database['public']['Tables']

export async function getUser() {
  const supabase = await createClient()
  return supabase.auth.getUser()
}

export async function getTeams(userId: string) {
  const supabase = await createClient()

  return supabase
    .from('teams')
    .select(`
      *,
      team_members!inner(
        role,
        user_id
      )
    `)
    .eq('team_members.user_id', userId)
    .order('created_at', { ascending: false })
}

export async function getProject(projectId: string) {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('projects')
    .select(`
      *,
      team:teams(
        id,
        name,
        slug
      )
    `)
    .eq('id', projectId)
    .single()

  if (error) throw error
  return data
}
```

### Cached Queries

```typescript
// queries/cached-queries.ts
import { unstable_cache } from 'next/cache'
import { createClient } from '../clients/server'

export const getUser = unstable_cache(
  async () => {
    const supabase = await createClient()
    return supabase.auth.getUser()
  },
  ['user'],
  {
    tags: ['user'],
    revalidate: 60 * 5, // 5 minutes
  }
)

export const getTeamProjects = unstable_cache(
  async (teamId: string) => {
    const supabase = await createClient()

    const { data, error } = await supabase
      .from('projects')
      .select('*')
      .eq('team_id', teamId)
      .order('created_at', { ascending: false })

    if (error) throw error
    return data
  },
  ['team-projects'],
  {
    tags: ['projects'],
    revalidate: 60, // 1 minute
  }
)

export const getProjectStats = unstable_cache(
  async (projectId: string, timeRange: { from: Date; to: Date }) => {
    const supabase = await createClient()

    // Complex aggregation query
    const { data, error } = await supabase
      .rpc('get_project_stats', {
        project_id: projectId,
        start_date: timeRange.from.toISOString(),
        end_date: timeRange.to.toISOString(),
      })

    if (error) throw error
    return data
  },
  ['project-stats'],
  {
    tags: ['stats'],
    revalidate: 60 * 5, // 5 minutes
  }
)
```

## Mutation Patterns

```typescript
// mutations/index.ts
import { createClient } from '../clients/server'
import { revalidateTag } from 'next/cache'

export async function createTeam(data: {
  name: string
  slug: string
}) {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) throw new Error('Unauthorized')

  // Start transaction
  const { data: team, error: teamError } = await supabase
    .from('teams')
    .insert({
      ...data,
      created_by: user.id,
    })
    .select()
    .single()

  if (teamError) throw teamError

  // Add creator as owner
  const { error: memberError } = await supabase
    .from('team_members')
    .insert({
      team_id: team.id,
      user_id: user.id,
      role: 'owner',
    })

  if (memberError) {
    // Rollback by deleting team
    await supabase.from('teams').delete().eq('id', team.id)
    throw memberError
  }

  // Invalidate cache
  revalidateTag('teams')

  return team
}

export async function updateProject(
  projectId: string,
  updates: Partial<Tables['projects']['Update']>
) {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('projects')
    .update(updates)
    .eq('id', projectId)
    .select()
    .single()

  if (error) throw error

  // Invalidate related caches
  revalidateTag('projects')
  revalidateTag(`project-${projectId}`)

  return data
}
```

## Type Generation

### Database Types

```typescript
// types/db.generated.ts
// Generated by Supabase CLI - DO NOT EDIT

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export interface Database {
  public: {
    Tables: {
      teams: {
        Row: {
          id: string
          name: string
          slug: string
          created_at: string
          updated_at: string
          created_by: string | null
        }
        Insert: {
          id?: string
          name: string
          slug: string
          created_at?: string
          updated_at?: string
          created_by?: string | null
        }
        Update: {
          id?: string
          name?: string
          slug?: string
          created_at?: string
          updated_at?: string
          created_by?: string | null
        }
      }
      // More tables...
    }
    Views: {
      // Database views
    }
    Functions: {
      get_project_stats: {
        Args: {
          project_id: string
          start_date: string
          end_date: string
        }
        Returns: {
          total_requests: number
          total_errors: number
          avg_latency: number
        }[]
      }
    }
  }
}
```

### Custom Types

```typescript
// types/db.ts
import type { Database } from './db.generated'

export type Tables<T extends keyof Database['public']['Tables']> =
  Database['public']['Tables'][T]['Row']

export type InsertTables<T extends keyof Database['public']['Tables']> =
  Database['public']['Tables'][T]['Insert']

export type UpdateTables<T extends keyof Database['public']['Tables']> =
  Database['public']['Tables'][T]['Update']

export type Enums<T extends keyof Database['public']['Enums']> =
  Database['public']['Enums'][T]

// Relationship types
export type TeamWithMembers = Tables<'teams'> & {
  team_members: (Tables<'team_members'> & {
    user: Tables<'users'>
  })[]
}

export type ProjectWithTeam = Tables<'projects'> & {
  team: Tables<'teams'>
}
```

## Storage Utilities

```typescript
// utils/storage.ts
import { createClient } from '../clients/client'

export async function uploadFile(
  bucket: string,
  path: string,
  file: File,
  options?: {
    cacheControl?: string
    contentType?: string
    upsert?: boolean
  }
) {
  const supabase = createClient()

  const { data, error } = await supabase.storage
    .from(bucket)
    .upload(path, file, {
      cacheControl: options?.cacheControl || '3600',
      contentType: options?.contentType,
      upsert: options?.upsert || false,
    })

  if (error) throw error

  // Get public URL
  const { data: { publicUrl } } = supabase.storage
    .from(bucket)
    .getPublicUrl(path)

  return { path: data.path, publicUrl }
}

export async function deleteFile(bucket: string, paths: string[]) {
  const supabase = createClient()

  const { error } = await supabase.storage
    .from(bucket)
    .remove(paths)

  if (error) throw error
}

export function getPublicUrl(bucket: string, path: string) {
  const supabase = createClient()

  const { data } = supabase.storage
    .from(bucket)
    .getPublicUrl(path)

  return data.publicUrl
}
```

## Real-time Subscriptions

```typescript
// Example real-time usage
import { createClient } from '@proxed/supabase/client'
import { useEffect } from 'react'

export function useProjectUpdates(projectId: string) {
  const supabase = createClient()

  useEffect(() => {
    const channel = supabase
      .channel(`project-${projectId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'projects',
          filter: `id=eq.${projectId}`,
        },
        (payload) => {
          console.log('Project updated:', payload)
          // Handle update
        }
      )
      .subscribe()

    return () => {
      supabase.removeChannel(channel)
    }
  }, [projectId, supabase])
}
```

## Testing Patterns

```typescript
// __tests__/queries.test.ts
import { describe, it, expect, beforeEach } from 'bun:test'
import { createClient } from '@supabase/supabase-js'

// Mock Supabase client
const mockSupabase = {
  from: (table: string) => ({
    select: () => ({
      eq: () => ({
        single: async () => ({ data: mockData, error: null }),
      }),
    }),
  }),
}

describe('Supabase Queries', () => {
  beforeEach(() => {
    // Reset mocks
  })

  it('should fetch user profile', async () => {
    // Test implementation
  })
})
```

## Best Practices

1. **Always use typed clients for type safety**
2. **Cache read queries with appropriate tags**
3. **Invalidate cache after mutations**
4. **Handle errors gracefully with proper types**
5. **Use RLS policies instead of client-side filtering**
6. **Batch related queries when possible**

## Common Pitfalls

❌ Don't use the service role key in client components
❌ Don't forget to handle Supabase errors
❌ Don't skip cache invalidation after mutations
❌ Don't create multiple client instances unnecessarily
❌ Don't expose sensitive data in client queries
